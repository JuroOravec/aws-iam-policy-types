import fps from 'fs/promises';
import path from 'path';
import { JSDOM } from 'jsdom';

const ALL_SERVICES_URL =
  'https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html';

interface PolicyActionResult {
  name: string;
  desc: string;
  link: string | null;
}

interface EnumValue {
  name: string;
  value: string;
  comment?: string[];
}

const wait = (ms?: number) => new Promise((res) => setTimeout(res, ms));

const uniqBy = <T>(arr: T[], keyFn: (val: T, index: number) => any = (x) => x): T[] => {
  const seen = new Set();
  return arr.reduce<T[]>((agg, val, index) => {
    const key = keyFn(val, index);
    if (seen.has(key)) return agg;

    seen.add(key);
    agg.push(val);
    return agg;
  }, []);
};

const fetchHtml = async (url: string) => {
  const html = await fetch(url).then((r) => r.text());
  const doc = new JSDOM(html).window.document;
  return doc;
};

const formatMultilineComment = (lines: string[]) => {
  const formattedDesc = '/**\n' + lines.map((c) => ` * ${c}`.trimEnd()).join('\n') + '\n */';
  return formattedDesc;
};

const formatEnum = (input: { name: string; comment?: string[]; values: EnumValue[] }) => {
  const { name, comment, values } = input;

  const formattedValues = values
    .map(({ name, value, comment }) => {
      const formattedComment = comment ? formatMultilineComment(comment) + '\n' : '';
      const formatted = `${formattedComment}${name} = ${value},`;
      return formatted;
    })
    .join('\n');

  const enumComment = comment ? formatMultilineComment(comment) + '\n' : '';
  const enumStr = `// AUTOGENERATED FILE - DO NOT EDIT\n\n${enumComment}export enum ${name} {\n${tabText(
    formattedValues,
    2
  )}\n}\n`;

  return enumStr;
};

const tabText = (text: string, spaces = 2) => {
  return text
    .split('\n')
    .map((t) => ' '.repeat(spaces) + t)
    .join('\n');
};

const extractAllServices = async () => {
  const doc = await fetchHtml(ALL_SERVICES_URL);

  // Select last list - Should be a list of all services
  const uls = [...doc.querySelectorAll('#main-content ul')];
  const servicesListEl = uls[uls.length - 1];

  const services = [...servicesListEl.querySelectorAll('li a')].reduce<
    { name: string; href: string }[]
  >((agg, el) => {
    if (!el.textContent) return agg;

    const relativeUrl = (el as HTMLAnchorElement).href;
    const absoluteUrlObj = new URL(ALL_SERVICES_URL);
    const absolutePath = path.resolve(absoluteUrlObj.pathname, '..', relativeUrl);
    absoluteUrlObj.pathname = absolutePath;

    agg.push({
      name: el.textContent?.trim(),
      href: absoluteUrlObj.toString(),
    });
    return agg;
  }, []);

  return services;
};

const extractAwsPolicyActionsFromServicePage = (doc: Document) => {
  let rowsToIgnore = 0;

  const servicePrefix = doc.querySelector('code')?.textContent?.trim().toLowerCase();
  if (!servicePrefix) {
    throw Error('Failed to extract service prefix from document');
  }

  const actions = [
    ...(doc.querySelector('.table-container tbody')?.querySelectorAll('tr') ?? []),
  ].reduce<PolicyActionResult[]>((agg, el) => {
    // Some actions span multiple rows, so we ignore the additional rows with this
    if (rowsToIgnore > 0) {
      rowsToIgnore--;
      return agg;
    }

    const [nameEl, descEl] = el.querySelectorAll('td');
    const linkEl = nameEl.querySelector('a');

    if (nameEl.rowSpan) rowsToIgnore = nameEl.rowSpan - 1;

    const name = linkEl?.textContent?.trim();
    if (!name) return agg;

    const desc = descEl.textContent?.trim() || '';
    const link = linkEl?.href ?? null;

    agg.push({
      name,
      link,
      desc,
    });

    return agg;
  }, []);

  return { actions, servicePrefix };
};

const formatAwsPolicyActionsForService = (input: {
  url: string;
  serviceName: string;
  servicePrefix: string;
  actions: PolicyActionResult[];
}) => {
  const { actions, serviceName, servicePrefix, url } = input;

  const formattedActions = actions.map(({ desc, link, name }): EnumValue => {
    // Split into chunks of up to 80 chars
    // See https://stackoverflow.com/a/8359929/9788634
    const comment = [...(desc.match(/.{1,79}\s?/g) || [])].filter(Boolean);
    if (link) {
      comment.push('', `See ${link}`);
    }
    const value = `'${servicePrefix}:${name}'`;

    return { name, value, comment };
  });

  const formattedPrefix = servicePrefix
    .split('-')
    .map((s) => s[0].toUpperCase() + s.slice(1))
    .join('');

  const enumName = `Aws${formattedPrefix}Actions`;
  const enumComment = [
    `All IAM policy actions for ${serviceName} (${servicePrefix.toUpperCase()})`,
    '',
    `Extracted by \`aws-iam-policy\` from`,
    url,
    '',
    new Date().toISOString(),
  ];
  const actionsEnum = formatEnum({
    name: enumName,
    comment: enumComment,
    values: formattedActions,
  });

  return { name: enumName, content: actionsEnum };
};

export const extract = async () => {
  // Clear the dir where we save the extracted files
  const actionsDir = path.join(__dirname, 'actions');
  await fps.rm(actionsDir, { recursive: true, force: true });
  await fps.mkdir(actionsDir, { recursive: true });

  // Extract the list of all services
  const services = await extractAllServices();

  const importPaths: { name: string; path: string }[] = [];
  for (const service of services) {
    // Extract specific page
    const doc = await fetchHtml(service.href);
    const { actions, servicePrefix } = await extractAwsPolicyActionsFromServicePage(doc);
    const { name, content } = formatAwsPolicyActionsForService({
      url: service.href,
      serviceName: service.name,
      servicePrefix,
      actions,
    });

    // Save it to a file
    const filename = path.join(actionsDir, `${servicePrefix}.ts`);
    await fps.writeFile(filename, content, 'utf-8');

    // Allow to import the file from the package
    importPaths.push({ name, path: `./actions/${servicePrefix}` });

    // Wait to avoid making rate limiting against AWS docs
    await wait(250);
  }

  const uniqueImportPaths = uniqBy(importPaths, (p) => p.name);

  // Update the index file
  const indexFilename = path.join(__dirname, `index.ts`);
  const indexFileStr =
    '// AUTOGENERATED FILE - DO NOT EDIT\n\n' +
    uniqueImportPaths.map((p) => `export * from '${p.path}';`).join('\n') +
    "\n\nexport * from './types';\n";
  await fps.writeFile(indexFilename, indexFileStr, 'utf-8');

  // Create a type that joins all the generated enums
  const typeFilename = path.join(__dirname, 'types', 'autogenerated.ts');
  const typeFileStr =
    '// AUTOGENERATED FILE - DO NOT EDIT\n\n' +
    uniqueImportPaths.map((p) => `import type { ${p.name} } from '.${p.path}';`).join('\n') +
    '\n\nexport type AwsPolicyAction =\n' +
    uniqueImportPaths.map((p) => `  | ${p.name}`).join('\n') +
    ';\n';
  await fps.writeFile(typeFilename, typeFileStr, 'utf-8');
};

if (require.main === module) {
  extract();
}
